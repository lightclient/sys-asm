;;    __ ___________  ____                     
;;   / // /__  ( __ )( __ )____ __________ ___ 
;;  / // /_ / / __  / __  / __ `/ ___/ __ `__ \
;; /__  __// / /_/ / /_/ / /_/ (__  ) / / / / /
;;   /_/  /_/\____/\____/\__,_/____/_/ /_/ /_/ 
;;                                             
;; This is an implementation of EIP-4788's predeploy contract. It implements
;; two ring buffers to create bounded beacon root lookup. The first ring
;; buffer is a timestamp % buflen -> timestamp mapping. This is used to ensure
;; timestamp argument actually matches the stored root and isn't different
;; dividend. The second ring buffer store the beacon root. It's also keyed by
;; timestamp % buflen and the shifted right by buflen so the two don't overlap.
;;
;; The ring buffers can be visualized as follows:
;;
;;  buflen = 10
;; |--------------|--------------|
;; 0             10              20
;;   timestamps     beacon roots
;;
;; To get the corresponding beacon root for a specific timestamp, simply add
;; buflen to the timestamp's index in the first ring buffer. The sum will be
;; the storage slot in the second ring buffer where it is stored.


;; ----------------------------------------------------------------------------
;; MACROS ---------------------------------------------------------------------
;; ----------------------------------------------------------------------------

;; BUFLEN returns the HISTORY_BUFFER_LENGTH as defined in the EIP.
#define BUFLEN 8191

;; SYSADDR is the address which calls the contract to submit a new root.
#define SYSADDR 0xfffffffffffffffffffffffffffffffffffffffe

;; do_revert sets up and then executes a revert(0,0) operation.
#define %do_revert() {
        push0           ;; [0]
        push0           ;; [0, 0]
        revert          ;; []
}

;; ----------------------------------------------------------------------------
;; MACROS END -----------------------------------------------------------------
;; ----------------------------------------------------------------------------

.start:
        ;; Protect the submit routine by verifying the caller is equal to
        ;; sysaddr().
        caller           ;; [caller]
        push20 SYSADDR   ;; [sysaddr, caller]
        eq               ;; [sysaddr == caller]
        push1 @submit    ;; [submit_lbl, sysaddr == caller]
        jumpi            ;; []

        ;; Fallthrough if addresses don't match -- this means the caller intends
        ;; to read a root.

        ;; Check if calldata is equal to 32 bytes.
        push1 32         ;; [32]
        calldatasize     ;; [calldatasize, 32]
        eq               ;; [calldatasize == 32]

        ;; Jump to continue if length-check passed, otherwise revert.
        push1 @loadtime   ;; [loadtime_lbl, calldatasize == 32]
        jumpi            ;; []
        %do_revert()     ;; []

loadtime:
        ;; Load input timestamp.
        push0            ;; [0]
        calldataload     ;; [input_timestamp]
        dup1             ;; [input_timestamp, input_timestamp]

        ;; Jump to continue if timestamp is non-zero, otherwise revert.
        push1 @time_ok   ;; [time_ok_lbl, input_timestamp, input_timestamp]
        jumpi            ;; [input_timestamp]
        %do_revert()     ;; []

time_ok:
        ;; Compute the timestamp index and load from storage.
        push3 BUFLEN     ;; [buflen, input_timestamp]
        dup2             ;; [input_timestamp, buflen, input_timestamp]
        mod              ;; [time_index, input_timestamp]
        swap1            ;; [input_timestamp, time_index]
        dup2             ;; [time_index, input_timestamp, time_index]
        sload            ;; [stored_timestamp, input_timestamp, time_index]

        ;; Verify stored timestamp matches input timestamp. It's possible these
        ;; don't match if the slot has been overwritten by the ring buffer or if
        ;; the timestamp input wasn't a valid previous timestamp.
        eq               ;; [stored_timestamp == input_timestamp, time_index]
        push1 @loadroot   ;; [loadroot_lbl, input == timestamp, time_index]
        jumpi            ;; [time_index]
        %do_revert()     ;; []

loadroot:
        ;; Extend index to get root index.
        push3 BUFLEN     ;; [buflen, time_index]
        add              ;; [root_index]
        sload            ;; [root]

        ;; Write the retrieved root to memory so it can be returned.
        push0            ;; [0, root]
        mstore           ;; []

        ;; Return the root.
        push1 32         ;; [size]
        push0            ;; [offset, size]
        return           ;; []

submit:
        ;; Calculate the index the timestamp should be stored at, e.g.
        ;; time_index = (time % buflen).
        push3 BUFLEN     ;; [buflen]
        timestamp        ;; [time, buflen]
        mod              ;; [time % buflen]

        ;; Write timestamp into storage slot at time_index.
        timestamp        ;; [time, time_index]
        dup2             ;; [time_index, time, time_index]
        sstore           ;; [time_index]

        ;; Get root from calldata and write into root_index. No validation is
        ;; done on the input root. Becuase the routine is protected by a caller
        ;; check against sysaddr(), it's okay to assume the value is correctly
        ;; given.
        push0            ;; [0, time_index]
        calldataload     ;; [root, time_index]
        swap1            ;; [time_index, root]
        push3 BUFLEN     ;; [buflen, time_index, root]
        add              ;; [root_index, root]
        sstore           ;; []

        stop             ;; []
