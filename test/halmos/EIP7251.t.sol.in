// SPDX-License-Identifier: AGPL-3.0
pragma solidity >=0.8.0 <0.9.0;

import "forge-std/Test.sol";
import {SymTest} from "halmos-cheatcodes/SymTest.sol";

/*
 * Functional correctness test for the system contract bytecode in https://eips.ethereum.org/EIPS/eip-7251
 *
 * This test verifies that the geas implementation conforms to the specifications in EIP-7251.
 * It ensures the correctness of consolidation request processing, fee calculations, and storage integrity.
 * By leveraging symbolic execution, the test exhaustively explores all possible execution behaviors, providing higher confidence in the implementation.
 */

/// @custom:halmos --storage-layout generic
contract EIP7251Test is SymTest, Test {
    // constants defined in EIP-7251
    address constant CONSOLIDATION_REQUEST_PREDEPLOY_ADDRESS = address(0x0000000000000000000000000000000000000000);
    address constant SYSTEM_ADDRESS = address(0xffffFFFfFFffffffffffffffFfFFFfffFFFfFFfE);

    uint256 constant EXCESS_CONSOLIDATION_REQUESTS_STORAGE_SLOT = 0;
    uint256 constant CONSOLIDATION_REQUEST_COUNT_STORAGE_SLOT = 1;
    uint256 constant CONSOLIDATION_REQUEST_QUEUE_HEAD_STORAGE_SLOT = 2;
    uint256 constant CONSOLIDATION_REQUEST_QUEUE_TAIL_STORAGE_SLOT = 3;
    uint256 constant CONSOLIDATION_REQUEST_QUEUE_STORAGE_OFFSET = 4;
    uint256 constant MAX_CONSOLIDATION_REQUESTS_PER_BLOCK = 1;
    uint256 constant TARGET_CONSOLIDATION_REQUESTS_PER_BLOCK = 1;
    uint256 constant MIN_CONSOLIDATION_REQUEST_FEE = 1;
    uint256 constant CONSOLIDATION_REQUEST_FEE_UPDATE_FRACTION = 17;

    uint256 constant EXCESS_INHIBITOR = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;

    // auxiliary constants
    uint256 constant SLOTS_PER_ITEM = 4;   // padding (12 bytes) + source address (20 bytes) + source pubkey (48 bytes) + target pubkey (48 bytes)
    uint256 constant INPUT_SIZE = 96;      //                                                  source pubkey (48 bytes) + target pubkey (48 bytes)
    uint256 constant RECORD_SIZE = 116;    //                      source address (20 bytes) + source pubkey (48 bytes) + target pubkey (48 bytes)

    // variables for specifying correctness properties

    struct State {
        uint256 balance;
        uint256 excess;
        uint256 count;
        uint256 queueHeadIndex;
        uint256 queueTailIndex;
        uint256 anySlotValue;
    }

    State internal initState;
    uint256 internal anySlot; // a universally quantified variable representing any storage slot

    function setUp() public {
        // set the bytecode generated by `geas src/withdrawals/main.eas`
        vm.etch(CONSOLIDATION_REQUEST_PREDEPLOY_ADDRESS, hex"@bytecode@");

        // set symbolic storage and balance
        svm.enableSymbolicStorage(CONSOLIDATION_REQUEST_PREDEPLOY_ADDRESS);
        vm.deal(CONSOLIDATION_REQUEST_PREDEPLOY_ADDRESS, svm.createUint(96, "CONSOLIDATION_REQUEST_PREDEPLOY_ADDRESS.balance"));

        // set symbolic block info
        _setUpBlock();

        // create a symbol for an arbitrary storage slot number
        anySlot = svm.createUint256("anySlot");

        // record initial state
        initState = _getState();

        // assume valid initial state
        // TODO: compute the max value based on practical fee limit
        // NOTE: excess is set to uint256_max until the hard fork
        // vm.assume(initState.excess < 2**64);
        vm.assume(initState.count < 2**64);
        vm.assume(initState.queueHeadIndex <= initState.queueTailIndex);
        vm.assume(initState.queueTailIndex < 2**64);
    }

    /// @custom:halmos --loop 16 --array-lengths data={0,1,2,32,64,96,1024}
    function check_user_operation(address caller, uint256 value, bytes memory data) public {
        // user operation
        vm.assume(caller != SYSTEM_ADDRESS);

        // set symbolic balance for caller
        uint256 callerBalance = svm.createUint(96, "caller.balance");
        vm.deal(caller, callerBalance);

        // call the contract and capture the new contract state
        (bool success, bytes memory retdata, State memory newState) = _callContract(caller, value, data);

        // ensure balance updates
        if (success) {
            _check_balance_update(newState, value, caller, callerBalance);
        }

        // get_excess_consolidation_requests() operation
        if (data.length == 0) {
            if (success) {
                assertEq(uint256(bytes32(retdata)), initState.excess);
                // ensure no storage updates
                assertEq(newState.anySlotValue, initState.anySlotValue);
                assertEq(value, 0);
            } else {
                // reject callvalue when calldatasize == 0
                // https://github.com/lightclient/sys-asm/pull/28
                assertNotEq(value, 0);
            }

        // add_consolidation_request() operation
        } else if (data.length == INPUT_SIZE) {
            if (success) {
                // ensure count has increased
                assertEq(newState.count, initState.count + 1);

                // ensure new queue element
                assertEq(newState.queueTailIndex, initState.queueTailIndex + 1);
                uint256 queueTailSlot = CONSOLIDATION_REQUEST_QUEUE_STORAGE_OFFSET + initState.queueTailIndex * SLOTS_PER_ITEM;
                bytes memory queueItem = _getQueueItem(queueTailSlot);
                assertEq(queueItem, bytes.concat(bytes32(uint256(uint160(caller))), data));
                // ensure no dirty bits for source address
                assertEq(bytes12(this.slice(queueItem, 0, 12)), bytes12(0));

                // ensure sufficient fee
                assertGe(value, _getFee());

                // ensure no storage updates other than count, queue tail index, or the new queue item
                if (
                    anySlot != CONSOLIDATION_REQUEST_COUNT_STORAGE_SLOT &&                  // count
                    anySlot != CONSOLIDATION_REQUEST_QUEUE_TAIL_STORAGE_SLOT &&             // queue tail index
                    (anySlot < queueTailSlot || anySlot >= queueTailSlot + SLOTS_PER_ITEM)  // new queue item
                ) {
                    // NOTE: excess is not updated // TODO: figure out why
                    assertEq(newState.anySlotValue, initState.anySlotValue);
                }

                // ensure empty return data
                assertEq(retdata.length, 0);
            } else {
                // NOTE: the contract immediately reverts when excess == EXCESS_INHIBITOR
                if (initState.excess != EXCESS_INHIBITOR) {
                    // ensure that the failure is only due to insufficient fee
                    assertLt(value, _getFee());
                }
            }

        // invalid user operation
        } else {
            // ensure revert when calldatasize is neither 0 nor INPUT_SIZE
            assertFalse(success);
        }
    }

    /// @custom:halmos --loop 16 --array-lengths data={1024}
    function check_system_operation(address caller, uint256 value, bytes memory data) public {
        // system operation
        vm.assume(caller == SYSTEM_ADDRESS);

        // set symbolic balance for caller
        uint256 callerBalance = svm.createUint(96, "caller.balance");
        vm.deal(caller, callerBalance);

        // call the contract and capture the new contract state
        (bool success, bytes memory retdata, State memory newState) = _callContract(caller, value, data);

        assertTrue(success);

        // ensure excess update
        if (initState.excess != EXCESS_INHIBITOR) {
            assertEq(newState.excess, subcap(initState.excess + initState.count, TARGET_CONSOLIDATION_REQUESTS_PER_BLOCK));
        } else {
            // at the fork block
            assertEq(newState.excess, subcap(                   initState.count, TARGET_CONSOLIDATION_REQUESTS_PER_BLOCK));
        }

        // ensure count reset
        assertEq(newState.count, 0);

        uint256 oldQueueSize = sub(initState.queueTailIndex, initState.queueHeadIndex);
        uint256 newQueueSize = sub(newState.queueTailIndex, newState.queueHeadIndex);
        uint256 numDequeued = sub(oldQueueSize, newQueueSize);

        // ensure queue pointer updates
        if (oldQueueSize <= MAX_CONSOLIDATION_REQUESTS_PER_BLOCK) {
            assertEq(newState.queueHeadIndex, 0);
            assertEq(newState.queueTailIndex, 0);
        } else {
            assertEq(newState.queueTailIndex, initState.queueTailIndex);
        }

        // ensure max withdrawals per block
        assertLe(numDequeued, MAX_CONSOLIDATION_REQUESTS_PER_BLOCK);

        // ensure retdata size
        assertEq(retdata.length, RECORD_SIZE * numDequeued);

        // check retdata
        for (uint256 i = 0; i < numDequeued; i++) {
            // TODO: to avoid slowdown as iteration progresses. use push/pop feature once available.
            if (svm.createBool("check-retdata")) {
                uint256 queueCurrSlot = CONSOLIDATION_REQUEST_QUEUE_STORAGE_OFFSET + (initState.queueHeadIndex + i) * SLOTS_PER_ITEM;
                bytes memory queueCurrItem = _getQueueItem(queueCurrSlot);

                uint256 retOffset = RECORD_SIZE * i;
                // check source address
                assertEq(_getSource(queueCurrItem), address(uint160(bytes20(this.slice(retdata, retOffset + 0, retOffset + 20)))));

                // check source pubkey
                assertEq(_getSourcePubkey(queueCurrItem), this.slice(retdata, retOffset + 20, retOffset + 68));

                // check target pubkey
                assertEq(_getTargetPubkey(queueCurrItem), this.slice(retdata, retOffset + 68, retOffset + RECORD_SIZE));

                // NOTE: the else branch will continue with further iterations
                return;
            }
        }

        // ensure no storage update other than excess, count, and queue head/tail indexes
        // NOTE: "removed" queue elements are not reset to zero in storage, so they remain unchanged
        if (anySlot >= CONSOLIDATION_REQUEST_QUEUE_STORAGE_OFFSET) {
            assertEq(newState.anySlotValue, initState.anySlotValue);
        }
    }

    function _check_balance_update(State memory newState, uint256 value, address caller, uint256 callerBalance) internal view {
        if (caller != CONSOLIDATION_REQUEST_PREDEPLOY_ADDRESS) {
            assertEq(newState.balance, initState.balance + value);
            assertEq(caller.balance, callerBalance - value);
        } else {
            // caller == CONSOLIDATION_REQUEST_PREDEPLOY_ADDRESS
            // self transfer, no balance change
            assertEq(caller.balance, callerBalance);
            // new balance set earlier by vm.deal(caller, callerBalance)
            assertEq(newState.balance, callerBalance);
        }
    }

    function _setUpBlock() internal {
        vm.fee(svm.createUint256("block.basefee"));
        vm.chainId(svm.createUint256("block.chainid"));
        vm.coinbase(svm.createAddress("block.coinbase"));
        vm.difficulty(svm.createUint256("block.difficulty"));
        vm.warp(svm.createUint256("block.timestamp"));
        vm.roll(svm.createUint256("block.number"));
    }

    function _callContract(address caller, uint256 value, bytes memory data) internal returns (bool success, bytes memory retdata, State memory newState) {
        // call CONSOLIDATION_REQUEST_PREDEPLOY_ADDRESS
        vm.prank(caller);
        (success, retdata) = CONSOLIDATION_REQUEST_PREDEPLOY_ADDRESS.call{value: value}(data);

        // record the updated state
        newState = _getState();
    }

    function _getState() internal view returns (State memory) {
        uint256 balance = CONSOLIDATION_REQUEST_PREDEPLOY_ADDRESS.balance;

        uint256 excess = uint256(vm.load(CONSOLIDATION_REQUEST_PREDEPLOY_ADDRESS, bytes32(EXCESS_CONSOLIDATION_REQUESTS_STORAGE_SLOT)));
        uint256 count = uint256(vm.load(CONSOLIDATION_REQUEST_PREDEPLOY_ADDRESS, bytes32(CONSOLIDATION_REQUEST_COUNT_STORAGE_SLOT)));

        uint256 queueHeadIndex = uint256(vm.load(CONSOLIDATION_REQUEST_PREDEPLOY_ADDRESS, bytes32(CONSOLIDATION_REQUEST_QUEUE_HEAD_STORAGE_SLOT)));
        uint256 queueTailIndex = uint256(vm.load(CONSOLIDATION_REQUEST_PREDEPLOY_ADDRESS, bytes32(CONSOLIDATION_REQUEST_QUEUE_TAIL_STORAGE_SLOT)));

        uint256 anySlotValue = uint256(vm.load(CONSOLIDATION_REQUEST_PREDEPLOY_ADDRESS, bytes32(anySlot)));

        return State(balance, excess, count, queueHeadIndex, queueTailIndex, anySlotValue);
    }

    // retrieve a queue item at the specified slot
    function _getQueueItem(uint256 slot) internal view returns (bytes memory) {
        bytes32 item0 = vm.load(CONSOLIDATION_REQUEST_PREDEPLOY_ADDRESS, bytes32(slot));
        bytes32 item1 = vm.load(CONSOLIDATION_REQUEST_PREDEPLOY_ADDRESS, bytes32(slot + 1));
        bytes32 item2 = vm.load(CONSOLIDATION_REQUEST_PREDEPLOY_ADDRESS, bytes32(slot + 2));
        bytes32 item3 = vm.load(CONSOLIDATION_REQUEST_PREDEPLOY_ADDRESS, bytes32(slot + 3));
        return bytes.concat(item0, item1, item2, item3);
    }

    // extract the source address field from the given queue item
    function _getSource(bytes memory item) internal view returns (address) {
        return address(uint160(bytes20(this.slice(item, 12, 32))));
    }

    // extract the source pubkey field from the given queue item
    function _getSourcePubkey(bytes memory item) internal view returns (bytes memory) {
        return this.slice(item, 32, 80);
    }

    // extract the target pubkey field from the given queue item
    function _getTargetPubkey(bytes memory item) internal view returns (bytes memory) {
        return this.slice(item, 80, 128);
    }

    function _getFee() internal view returns (uint256) {
        return _fake_exponential(
            MIN_CONSOLIDATION_REQUEST_FEE,
            initState.excess,
            CONSOLIDATION_REQUEST_FEE_UPDATE_FRACTION
        );
    }

    // pseudocode from https://eips.ethereum.org/EIPS/eip-7251
    // NOTE: the purpose of this is to ensure that the geas implementation matches the pseudocode math, rather than verifying the math itself
    function _fake_exponential(uint256 factor, uint256 numerator, uint256 denominator) internal pure returns (uint256) {
        unchecked {
            uint256 i = 1;
            uint256 output = 0;
            uint256 numerator_accum = factor * denominator;
            while (numerator_accum > 0) {
                output += numerator_accum;
                numerator_accum = (numerator_accum * numerator) / (denominator * i);
                i += 1;
            }
            return output / denominator;
        }
    }

    // helpers

    // workaround for memory bytes slice
    function slice(bytes calldata data, uint256 start, uint256 end) external pure returns (bytes memory) {
        return data[start:end];
    }

    // compute max(x - y, 0)
    function subcap(uint256 x, uint256 y) internal pure returns (uint256) {
        if (y >= x) return 0;
        return x - y;
    }

    // ensure no overflow in subtraction
    function sub(uint256 x, uint256 y) internal pure returns (uint256) {
        assertGe(x, y);
        return x - y;
    }
}
